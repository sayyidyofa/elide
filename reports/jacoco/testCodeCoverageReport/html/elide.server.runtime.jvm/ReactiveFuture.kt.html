<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>ReactiveFuture.kt</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">reports</a> &gt; <a href="index.source.html" class="el_package">elide.server.runtime.jvm</a> &gt; <span class="el_source">ReactiveFuture.kt</span></div><h1>ReactiveFuture.kt</h1><pre class="source lang-java linenums">@file:Suppress(
  &quot;ReactiveStreamsPublisherImplementation&quot;,
  &quot;ReactiveStreamsSubscriberImplementation&quot;,
)

package elide.server.runtime.jvm

import com.google.api.core.ApiFuture
import com.google.api.core.ApiFutureToListenableFuture
import com.google.common.util.concurrent.Futures
import com.google.common.util.concurrent.ListenableFuture
import com.google.common.util.concurrent.MoreExecutors
import com.google.common.util.concurrent.SettableFuture
import elide.server.runtime.jvm.ReactiveFuture.Companion.wrap
import org.reactivestreams.Publisher
import org.reactivestreams.Subscriber
import org.reactivestreams.Subscription
import java.util.*
import java.util.concurrent.*
import java.util.concurrent.atomic.AtomicBoolean
import java.util.function.BiConsumer
import java.util.function.BiFunction
import java.util.function.Consumer
import java.util.function.Function
import javax.annotation.Nonnull
import javax.annotation.concurrent.Immutable
import javax.annotation.concurrent.ThreadSafe

/**
 * Adapts future/async value containers from different frameworks (namely, Reactive Java, Guava, and the JDK).
 *
 * Create a new `ReactiveFuture` by using any of the [wrap] factory methods. The resulting object is usable as a
 * [Publisher], [ListenableFuture], or [ApiFuture] (from GAX). This object simply wraps whatever inner object is
 * provided, and as such instances are lightweight; there is no default functionality after immediate construction in
 * most cases.&lt;/p&gt;
 *
 * **Caveat:** when using a [Publisher] as a [ListenableFuture] (i.e. wrapping a {@link Publisher} and then using any of
 * the typical future methods, like [ListenableFuture.addListener], the underlying publisher may not publish more than
 * one value. This is to prevent dropping intermediate values on the floor, silently, before dispatching the future's
 * callbacks, which generally only accept one value. Other than this, things should work &quot;as expected&quot; whether you're
 * looking at them from a Guava, JDK, or Reactive perspective.
 *
 * @see Publisher Reactive Java type adapted by this object.
 * @see ListenableFuture Guava's extension of the JDK's basic {@link Future}, which adds listener support.
 * @see ApiFuture Lightweight Guava-like future meant to avoid dependencies on Java in API libraries.
 * @see wrap To wrap a [Publisher], [ListenableFuture], or [ApiFuture].
 */
@Immutable
@ThreadSafe
public class ReactiveFuture&lt;R&gt; : Publisher&lt;R?&gt;, ListenableFuture&lt;R?&gt;, ApiFuture&lt;R?&gt; {
  /** Inner future, if one is set. Otherwise [Optional.empty].  */
  private val future: Optional&lt;ListenableFuture&lt;R&gt;&gt;

  /** If a `publisher` is present, this object adapts it to a `future`.  */
  private val publisherAdapter: PublisherListenableFuture&lt;R&gt;?

  /** If a `future` is present, this object adapts it to a `publisher`.  */
  private val futureAdapter: ListenableFuturePublisher&lt;R&gt;?

  /** If a `future` is present, this object adapts it to a `publisher`.  */
  private val javaFutureAdapter: CompletableFuturePublisher&lt;R&gt;?

  /**
   * Spawn a reactive/future adapter in a reactive context, from a [Publisher]. Constructing a reactive future in
   * this manner causes the object to operate in a &quot;publisher-backed&quot; mode.
   *
   * @param publisher Publisher to work with.
   */
<span class="nc" id="L69">  private constructor(publisher: Publisher&lt;R&gt;) {</span>
<span class="nc" id="L70">    future = Optional.empty()</span>
<span class="nc" id="L71">    futureAdapter = null</span>
<span class="nc" id="L72">    publisherAdapter = PublisherListenableFuture(publisher)</span>
<span class="nc" id="L73">    javaFutureAdapter = null</span>
<span class="nc" id="L74">  }</span>

  /**
   * Spawn a reactive/future adapter in a future context, from a [ListenableFuture]. Constructing a reactive
   * future in this manner causes the object to operate in a &quot;future-backed&quot; mode.
   *
   * @param op Future to work with.
   * @param executor Executor to use when running callbacks.
   */
<span class="nc" id="L83">  private constructor(op: ListenableFuture&lt;R&gt;, executor: Executor) {</span>
<span class="nc" id="L84">    future = Optional.of(op)</span>
<span class="nc" id="L85">    futureAdapter = ListenableFuturePublisher(op, executor)</span>
<span class="nc" id="L86">    publisherAdapter = null</span>
<span class="nc" id="L87">    javaFutureAdapter = null</span>
<span class="nc" id="L88">  }</span>

  /**
   * Spawn a reactive/future adapter in a future context, from a [CompletableFuture]. Constructing a reactive
   * future in this manner causes the object to operate in a &quot;future-backed&quot; mode.
   *
   * @param op Future to work with.
   * @param executor Executor to use when running callbacks.
   */
<span class="nc" id="L97">  private constructor(op: CompletableFuture&lt;R&gt;, executor: Executor) {</span>
<span class="nc" id="L98">    future = Optional.empty()</span>
<span class="nc" id="L99">    futureAdapter = null</span>
<span class="nc" id="L100">    publisherAdapter = null</span>
<span class="nc" id="L101">    javaFutureAdapter = CompletableFuturePublisher(op, executor)</span>
<span class="nc" id="L102">  }</span>

  /** @return Internal future representation. */
  @Suppress(&quot;ReturnCount&quot;)
  private fun resolveFuture(): ListenableFuture&lt;R&gt; {
<span class="nc bnc" id="L107" title="All 4 branches missed.">    if (publisherAdapter != null) return publisherAdapter else if (javaFutureAdapter != null) return javaFutureAdapter</span>
<span class="nc" id="L108">    return future.get()</span>
  }

  /** @return Internal publisher representation. */
  @Suppress(&quot;ReturnCount&quot;)
  private fun resolvePublisher(): Publisher&lt;R&gt; {
<span class="nc bnc" id="L114" title="All 4 branches missed.">    if (futureAdapter != null) return futureAdapter else if (javaFutureAdapter != null) return javaFutureAdapter</span>
<span class="nc" id="L115">    return Objects.requireNonNull(publisherAdapter)!!</span>
  }

  // -- Compliance: Publisher -- //

  /**
   * Request [Publisher] to start streaming data.
   *
   *
   * This is a &quot;factory method&quot; and can be called multiple times, each time starting a new [Subscription]. Each
   * [Subscription] will work for only a single [Subscriber]. A [Subscriber] should only subscribe
   * once to a single [Publisher]. If the [Publisher] rejects the subscription attempt or otherwise fails it
   * will signal the error via [Subscriber.onError].
   *
   * @param subscriber the [Subscriber] that will consume signals from this [Publisher].
   */
  override fun subscribe(subscriber: Subscriber&lt;in R?&gt;) {
<span class="nc" id="L132">    resolvePublisher().subscribe(subscriber)</span>
<span class="nc" id="L133">  }</span>

  // -- Compliance: Listenable Future -- //

  /**
   * Registers a listener to be [run][Executor.execute] on the given executor. The listener will run
   * when the `Future`'s computation is [complete][Future.isDone] or, if the computation is already
   * complete, immediately.
   *
   *
   * There is no guaranteed ordering of execution of listeners, but any listener added through this method is
   * guaranteed to be called once the computation is complete.
   *
   *
   * Exceptions thrown by a listener will be propagated up to the executor. Any exception thrown during
   * `Executor.execute` (e.g., a `RejectedExecutionException` or an exception thrown by
   * [direct execution][MoreExecutors.directExecutor]) will be caught and logged.
   *
   *
   * Note: For fast, lightweight listeners that would be safe to execute in any thread, consider
   * [MoreExecutors.directExecutor]. Otherwise, avoid it. Heavyweight `directExecutor` listeners can cause
   * problems, and these problems can be difficult to reproduce because they depend on timing. For example:
   *
   *  * The listener may be executed by the caller of `addListener`. That caller may be a
   * UI thread or other latency-sensitive thread. This can harm UI responsiveness.
   *  * The listener may be executed by the thread that completes this `Future`. That
   * thread may be an internal system thread such as an RPC network thread. Blocking that
   * thread may stall progress of the whole system. It may even cause a deadlock.
   *  * The listener may delay other listeners, even listeners that are not themselves `directExecutor` listeners.
   *
   *
   *
   * This is the most general listener interface. For common operations performed using listeners, see
   * [Futures]. For a simplified but general listener interface, see
   * [addCallback()][Futures.addCallback].
   *
   *
   * Memory consistency effects: Actions in a thread prior to adding a listener
   * [*happen-before*](https://docs.oracle.com/javase/specs/jls/se7/html/jls-17.html#jls-17.4.5) its execution begins,
   * perhaps in another thread.
   *
   *
   * Guava implementations of `ListenableFuture` promptly release references to listeners after executing
   * them.
   *
   * @param listener the listener to run when the computation is complete.
   * @param executor the executor to run the listener in
   * @throws RejectedExecutionException if we tried to execute the listener immediately but the executor rejected it.
   */
  @Throws(RejectedExecutionException::class)
  override fun addListener(listener: Runnable, executor: Executor) {
<span class="nc" id="L184">    resolveFuture().addListener(listener, executor)</span>
<span class="nc" id="L185">  }</span>

  /**
   * Attempts to cancel execution of this task.  This attempt will fail if the task has already completed, has already
   * been cancelled, or could not be cancelled for some other reason. If successful, and this task has not started when
   * `cancel` is called, this task should never run.  If the task has already started, then the
   * `mayInterruptIfRunning` parameter determines whether the thread executing this task should be interrupted in
   * an attempt to stop the task.
   *
   *
   * After this method returns, subsequent calls to [.isDone] will always return `true`.  Subsequent
   * calls to [.isCancelled] will always return `true` if this method returned `true`.
   *
   * @param mayInterruptIfRunning `true` if the thread executing this task should be interrupted; otherwise,
   * in-progress tasks are allowed to complete
   * @return `false` if the task could not be cancelled, typically because it has already completed normally;
   * `true` otherwise.
   */
  override fun cancel(mayInterruptIfRunning: Boolean): Boolean {
<span class="nc" id="L204">    return resolveFuture().cancel(mayInterruptIfRunning)</span>
  }

  /**
   * Returns `true` if this task was cancelled before it completed normally. This defers to the underlying future,
   * or a wrapped object if using a [Publisher].
   *
   * @return `true` if this task was cancelled before it completed
   */
  override fun isCancelled(): Boolean {
<span class="nc" id="L214">    return resolveFuture().isCancelled</span>
  }

  /**
   * Returns `true` if this task completed. This defers to the underlying future, or a wrapped object if using a
   * Reactive Java [Publisher].
   *
   * Completion may be due to normal termination, an exception, or cancellation -- in all of these cases, this method
   * will return `true`.
   *
   * @return `true` if this task completed.
   */
  override fun isDone(): Boolean {
<span class="nc" id="L227">    return resolveFuture().isDone</span>
  }

  /**
   * Waits if necessary for the computation to complete, and then retrieves its result.
   *
   *
   * It is generally recommended to use the variant of this method which specifies a timeout - one must handle the
   * additional [TimeoutException], but on the other hand the computation can never infinitely block if an async
   * value does not materialize.
   *
   * @see .get
   * @return the computed result.
   * @throws CancellationException if the computation was cancelled
   * @throws ExecutionException    if the computation threw an exception
   * @throws InterruptedException  if the current thread was interrupted while waiting
   */
  @Throws(InterruptedException::class, ExecutionException::class)
  override fun get(): R {
<span class="nc" id="L246">    return resolveFuture().get()</span>
  }

  /**
   * Waits if necessary for at most the given time for the computation to complete, and then retrieves its result, if
   * available.
   *
   * @param timeout the maximum time to wait
   * @param unit    the time unit of the timeout argument
   * @return the computed result
   * @throws CancellationException if the computation was cancelled
   * @throws ExecutionException    if the computation threw an exception
   * @throws InterruptedException  if the current thread was interrupted while waiting
   * @throws TimeoutException      if the wait timed out
   */
  @Throws(InterruptedException::class, ExecutionException::class, TimeoutException::class)
  override fun get(timeout: Long, unit: TimeUnit): R {
<span class="nc" id="L263">    return resolveFuture()[timeout, unit]</span>
  }

  /**
   * Structure that adapts a [Publisher] to a [ListenableFuture] interface. We accomplish this by
   * immediately subscribing to the publisher with a callback that dispatches a [SettableFuture].
   *
   *
   * This object is used in the specific circumstance of wrapping a [Publisher], and then using the wrapped
   * object as a [ListenableFuture] (or any descendent or compliant implementation thereof).
   *
   * @param &lt;T&gt; Generic type returned by the future.
  &lt;/T&gt; */
<span class="nc" id="L276">  @Immutable</span>
  @ThreadSafe
<span class="nc" id="L278">  public class PublisherListenableFuture&lt;T&gt; internal constructor(publisher: Publisher&lt;T&gt;) :</span>
    ListenableFuture&lt;T&gt;, Publisher&lt;T&gt; {
    /** Whether we have received a value.  */
<span class="nc" id="L281">    private val received = AtomicBoolean(false)</span>

    /** Whether we have completed acquiring a value.  */
<span class="nc" id="L284">    private val completed = AtomicBoolean(false)</span>

    /** Whether we have been cancelled.  */
<span class="nc" id="L287">    private val cancelled = AtomicBoolean(false)</span>

    /** Describes the list of proxied subscribers.  */
<span class="nc" id="L290">    private val subscribers: MutableMap&lt;String, Subscriber&lt;in T&gt;&gt; = ConcurrentHashMap()</span>

    /** Converted/pass-through future value.  */
<span class="nc" id="L293">    private val future: SettableFuture&lt;T&gt; = SettableFuture.create()</span>

    /** Subscription, so we can propagate cancellation.  */
    @Volatile private var subscription: Subscription? = null

    /**
     * Private constructor.
     */
<span class="nc" id="L301">    init {</span>
<span class="nc" id="L302">      publisher.subscribe(object : Subscriber&lt;T&gt; {</span>
        override fun onSubscribe(s: Subscription) {
<span class="nc" id="L304">          subscription = s</span>
<span class="nc" id="L305">        }</span>

        override fun onNext(t: T) {
<span class="nc bnc" id="L308" title="All 2 branches missed.">          if (received.compareAndSet(false, true)) {</span>
<span class="nc" id="L309">            proxyExecute { sub: Subscriber&lt;in T&gt; -&gt;</span>
<span class="nc" id="L310">              sub.onNext(</span>
<span class="nc" id="L311">                t</span>
              )
<span class="nc" id="L313">            }</span>
<span class="nc" id="L314">            future.set(t)</span>
<span class="nc" id="L315">            return</span>
          }
<span class="nc" id="L317">          onError(</span>
<span class="nc" id="L318">            IllegalStateException(</span>
<span class="nc" id="L319">              &quot;Cannot publish multiple items through `ReactiveFuture`.&quot;</span>
            )
          )
<span class="nc" id="L322">        }</span>

        override fun onError(t: Throwable) {
<span class="nc bnc" id="L325" title="All 2 branches missed.">          if (!completed.get()) {</span>
<span class="nc" id="L326">            proxyExecute { sub: Subscriber&lt;in T&gt; -&gt;</span>
<span class="nc" id="L327">              sub.onError(</span>
<span class="nc" id="L328">                t</span>
              )
<span class="nc" id="L330">            }</span>
<span class="nc" id="L331">            future.setException(t)</span>
          }
<span class="nc" id="L333">        }</span>

        override fun onComplete() {
<span class="nc bnc" id="L336" title="All 2 branches missed.">          if (completed.compareAndSet(false, true)) {</span>
<span class="nc" id="L337">            proxyExecute { obj: Subscriber&lt;in T&gt; -&gt; obj.onComplete() }</span>
<span class="nc" id="L338">            this@PublisherListenableFuture.clear()</span>
          }
<span class="nc" id="L340">        }</span>
      })
<span class="nc" id="L342">    }</span>

    /**
     * Call something on each proxied publisher subscription, if any.
     *
     * @param operation Operation to execute. Called for each subscriber.
     */
    private fun proxyExecute(operation: Consumer&lt;Subscriber&lt;in T&gt;&gt;) {
<span class="nc bnc" id="L350" title="All 4 branches missed.">      if (subscribers.isNotEmpty()) {</span>
<span class="nc" id="L351">        subscribers.values.forEach(operation)</span>
      }
<span class="nc" id="L353">    }</span>

    /**
     * Remove all subscribers and clear references to futures/publishers/listeners.
     */
    private fun clear() {
<span class="nc" id="L359">      subscribers.clear()</span>
<span class="nc" id="L360">      subscription = null</span>
<span class="nc" id="L361">    }</span>

    /**
     * Drop a subscription (after proxied [Subscription.cancel] is called).
     *
     * @param id ID of the subscription to drop.
     */
    private fun dropSubscription(id: String) {
<span class="nc" id="L369">      subscribers[id]!!.onComplete()</span>
<span class="nc" id="L370">      subscribers.remove(id)</span>
<span class="nc" id="L371">    }</span>

    // -- Interface Compliance: Publisher -- //
    override fun subscribe(s: Subscriber&lt;in T&gt;) {
<span class="nc" id="L375">      val id = subscribers.size.toString()</span>
<span class="nc" id="L376">      val sub: Subscription = object : Subscription {</span>
        override fun request(n: Long) {
<span class="nc" id="L378">          subscription!!.request(n)</span>
<span class="nc" id="L379">        }</span>

        override fun cancel() {
          // kill self
<span class="nc" id="L383">          dropSubscription(id)</span>
<span class="nc" id="L384">        }</span>
      }
<span class="nc" id="L386">      subscribers[id] = s</span>
<span class="nc" id="L387">      s.onSubscribe(sub)</span>
<span class="nc" id="L388">    }</span>

    // -- Interface Compliance: Listenable Future -- //
    override fun addListener(runnable: Runnable, executor: Executor) {
<span class="nc" id="L392">      future.addListener(runnable, executor)</span>
<span class="nc" id="L393">    }</span>

    override fun cancel(mayInterruptIfRunning: Boolean): Boolean {
<span class="nc" id="L396">      var cancelled = false</span>
<span class="nc bnc" id="L397" title="All 4 branches missed.">      if (!completed.get() &amp;&amp; this.cancelled.compareAndSet(false, true)) {</span>
<span class="nc" id="L398">        proxyExecute { obj: Subscriber&lt;in T&gt; -&gt; obj.onComplete() } // dispatch `onComplete` for any subscribers</span>
<span class="nc" id="L399">        subscription!!.cancel() // cancel upwards</span>
<span class="nc" id="L400">        cancelled = future.cancel(mayInterruptIfRunning) // cancel future</span>
<span class="nc" id="L401">        this.clear() // clear references</span>
      }
<span class="nc" id="L403">      return cancelled</span>
    }

    override fun isCancelled(): Boolean {
<span class="nc" id="L407">      return cancelled.get()</span>
    }

    override fun isDone(): Boolean {
<span class="nc bnc" id="L411" title="All 4 branches missed.">      return completed.get() || cancelled.get()</span>
    }

    @Throws(InterruptedException::class, ExecutionException::class)
    override fun get(): T {
<span class="nc" id="L416">      return future.get()</span>
    }

    @Throws(InterruptedException::class, ExecutionException::class, TimeoutException::class)
    override fun get(timeout: Long, unit: TimeUnit): T {
<span class="nc" id="L421">      return future[timeout, unit]</span>
    }
  }

  /**
   * Structure that adapts Java's [CompletableFuture] to a Reactive Java [Publisher], which publishes one
   * item - either the result of the computation, or an error.
   *
   *
   * This object is used in the specific circumstance that a [CompletableFuture] is wrapped by a
   * [ReactiveFuture], and then used within the Reactive Java or Guava ecosystems as a [Publisher] or a
   * [ListenableFuture] (or [ApiFuture]), or a descendent thereof. As in [ListenableFuturePublisher],
   * we simply set the callback for the future value, upon item-request (one cycle is allowed), and propagate any events
   * received to the publisher.
   *
   * @param &lt;T&gt; Emit type for this adapter. Matches the future it wraps.
  &lt;/T&gt; */
<span class="nc" id="L438">  @Suppress(&quot;TooManyFunctions&quot;)</span>
<span class="nc" id="L439">  public class CompletableFuturePublisher&lt;T&gt; internal constructor(</span>
<span class="nc" id="L440">    @field:Nonnull</span>
    @param:Nonnull
    private val future: CompletableFuture&lt;T&gt;,
    callbackExecutor: Executor
  ) : Publisher&lt;T&gt;, ListenableFuture&lt;T&gt;, CompletionStage&lt;T&gt; {
    private val stage: CompletionStage&lt;T&gt;
    private val callbackExecutor: Executor

    /**
     * Construct an adapter that propagates signals from a `CompletableFuture` to a `Publisher`.
     */
<span class="nc" id="L451">    init {</span>
<span class="nc" id="L452">      stage = future</span>
<span class="nc" id="L453">      this.callbackExecutor = callbackExecutor</span>
<span class="nc" id="L454">    }</span>
    /* == `Future`/`ListenableFuture` Interface Compliance == */
    /** @inheritDoc
     */
    override fun subscribe(subscriber: Subscriber&lt;in T&gt;) {
<span class="nc" id="L459">      Objects.requireNonNull(subscriber, &quot;Subscriber cannot be null&quot;)</span>
<span class="nc" id="L460">      subscriber.onSubscribe(CompletableFutureSubscription(future, subscriber, callbackExecutor))</span>
<span class="nc" id="L461">    }</span>

    /** @inheritDoc
     */
    override fun addListener(runnable: Runnable, executor: Executor) {
<span class="nc" id="L466">      future.thenRunAsync(runnable, executor)</span>
<span class="nc" id="L467">    }</span>

    /** @inheritDoc
     */
    override fun cancel(mayInterruptIfRunning: Boolean): Boolean {
<span class="nc" id="L472">      return future.cancel(mayInterruptIfRunning)</span>
    }

    /** @inheritDoc
     */
    override fun isCancelled(): Boolean {
<span class="nc" id="L478">      return future.isCancelled</span>
    }

    /** @inheritDoc
     */
    override fun isDone(): Boolean {
<span class="nc" id="L484">      return future.isDone</span>
    }

    /** @inheritDoc
     */
    @Throws(InterruptedException::class, ExecutionException::class)
    override fun get(): T {
<span class="nc" id="L491">      return future.get()</span>
    }

    /** @inheritDoc
     */
    @Throws(InterruptedException::class, ExecutionException::class, TimeoutException::class)
    override fun get(timeout: Long, unit: TimeUnit): T {
<span class="nc" id="L498">      return future[timeout, unit]</span>
    }
    /* == `CompletionStage` Interface Compliance == */
    /** @inheritDoc
     */
    override fun &lt;U&gt; thenApply(fn: Function&lt;in T, out U&gt;): CompletionStage&lt;U&gt; {
<span class="nc" id="L504">      return stage.thenApply(fn)</span>
    }

    /** @inheritDoc
     */
    override fun &lt;U&gt; thenApplyAsync(fn: Function&lt;in T, out U&gt;): CompletionStage&lt;U&gt; {
<span class="nc" id="L510">      return stage.thenApplyAsync(fn)</span>
    }

    /** @inheritDoc
     */
    override fun &lt;U&gt; thenApplyAsync(fn: Function&lt;in T, out U&gt;, executor: Executor): CompletionStage&lt;U&gt; {
<span class="nc" id="L516">      return stage.thenApplyAsync(fn, executor)</span>
    }

    /** @inheritDoc
     */
    override fun thenAccept(action: Consumer&lt;in T&gt;): CompletionStage&lt;Void&gt; {
<span class="nc" id="L522">      return stage.thenAccept(action)</span>
    }

    /** @inheritDoc
     */
    override fun thenAcceptAsync(action: Consumer&lt;in T&gt;): CompletionStage&lt;Void&gt; {
<span class="nc" id="L528">      return stage.thenAcceptAsync(action)</span>
    }

    /** @inheritDoc
     */
    override fun thenAcceptAsync(action: Consumer&lt;in T&gt;, executor: Executor): CompletionStage&lt;Void&gt; {
<span class="nc" id="L534">      return stage.thenAcceptAsync(action, executor)</span>
    }

    /** @inheritDoc
     */
    override fun thenRun(action: Runnable): CompletionStage&lt;Void&gt; {
<span class="nc" id="L540">      return stage.thenRun(action)</span>
    }

    /** @inheritDoc
     */
    override fun thenRunAsync(action: Runnable): CompletionStage&lt;Void&gt; {
<span class="nc" id="L546">      return stage.thenRunAsync(action)</span>
    }

    /** @inheritDoc
     */
    override fun thenRunAsync(action: Runnable, executor: Executor): CompletionStage&lt;Void&gt; {
<span class="nc" id="L552">      return stage.thenRunAsync(action, executor)</span>
    }

    /** @inheritDoc
     */
    override fun &lt;U, V&gt; thenCombine(
      other: CompletionStage&lt;out U?&gt;,
      fn: BiFunction&lt;in T, in U?, out V&gt;
    ): CompletionStage&lt;V&gt; {
<span class="nc" id="L561">      return stage.thenCombine(other, fn)</span>
    }

    /** @inheritDoc
     */
    override fun &lt;U, V&gt; thenCombineAsync(
      other: CompletionStage&lt;out U?&gt;,
      fn: BiFunction&lt;in T, in U?, out V&gt;
    ): CompletionStage&lt;V&gt; {
<span class="nc" id="L570">      return stage.thenCombineAsync(other, fn)</span>
    }

    /** @inheritDoc
     */
    override fun &lt;U, V&gt; thenCombineAsync(
      other: CompletionStage&lt;out U?&gt;,
      fn: BiFunction&lt;in T, in U?, out V&gt;,
      executor: Executor
    ): CompletionStage&lt;V&gt; {
<span class="nc" id="L580">      return stage.thenCombineAsync(other, fn, executor)</span>
    }

    /** @inheritDoc
     */
    override fun &lt;U&gt; thenAcceptBoth(
      other: CompletionStage&lt;out U?&gt;,
      action: BiConsumer&lt;in T, in U?&gt;
    ): CompletionStage&lt;Void&gt; {
<span class="nc" id="L589">      return stage.thenAcceptBoth(other, action)</span>
    }

    /** @inheritDoc
     */
    override fun &lt;U&gt; thenAcceptBothAsync(
      other: CompletionStage&lt;out U?&gt;,
      action: BiConsumer&lt;in T, in U?&gt;
    ): CompletionStage&lt;Void&gt; {
<span class="nc" id="L598">      return stage.thenAcceptBothAsync(other, action)</span>
    }

    /** @inheritDoc
     */
    override fun &lt;U&gt; thenAcceptBothAsync(
      other: CompletionStage&lt;out U?&gt;,
      action: BiConsumer&lt;in T, in U?&gt;,
      executor: Executor
    ): CompletionStage&lt;Void&gt; {
<span class="nc" id="L608">      return stage.thenAcceptBothAsync(other, action, executor)</span>
    }

    /** @inheritDoc
     */
    override fun runAfterBoth(other: CompletionStage&lt;*&gt;?, action: Runnable): CompletionStage&lt;Void&gt; {
<span class="nc" id="L614">      return stage.runAfterBoth(other, action)</span>
    }

    /** @inheritDoc
     */
    override fun runAfterBothAsync(other: CompletionStage&lt;*&gt;?, action: Runnable): CompletionStage&lt;Void&gt; {
<span class="nc" id="L620">      return stage.runAfterBothAsync(other, action)</span>
    }

    /** @inheritDoc
     */
    override fun runAfterBothAsync(
      other: CompletionStage&lt;*&gt;?,
      action: Runnable,
      executor: Executor
    ): CompletionStage&lt;Void&gt; {
<span class="nc" id="L630">      return stage.runAfterBothAsync(other, action, executor)</span>
    }

    /** @inheritDoc
     */
    override fun &lt;U&gt; applyToEither(other: CompletionStage&lt;out T&gt;, fn: Function&lt;in T, U&gt;): CompletionStage&lt;U&gt; {
<span class="nc" id="L636">      return stage.applyToEither(other, fn)</span>
    }

    /** @inheritDoc
     */
    override fun &lt;U&gt; applyToEitherAsync(other: CompletionStage&lt;out T&gt;, fn: Function&lt;in T, U&gt;): CompletionStage&lt;U&gt; {
<span class="nc" id="L642">      return stage.applyToEitherAsync(other, fn)</span>
    }

    /** @inheritDoc
     */
    override fun &lt;U&gt; applyToEitherAsync(
      other: CompletionStage&lt;out T&gt;,
      fn: Function&lt;in T, U&gt;,
      executor: Executor
    ): CompletionStage&lt;U&gt; {
<span class="nc" id="L652">      return stage.applyToEitherAsync(other, fn, executor)</span>
    }

    /** @inheritDoc
     */
    override fun acceptEither(
      other: CompletionStage&lt;out T&gt;,
      action: Consumer&lt;in T&gt;
    ): CompletionStage&lt;Void&gt; {
<span class="nc" id="L661">      return stage.acceptEither(other, action)</span>
    }

    /** @inheritDoc
     */
    override fun acceptEitherAsync(
      other: CompletionStage&lt;out T&gt;,
      action: Consumer&lt;in T&gt;
    ): CompletionStage&lt;Void&gt; {
<span class="nc" id="L670">      return stage.acceptEitherAsync(other, action)</span>
    }

    /** @inheritDoc
     */
    override fun acceptEitherAsync(
      other: CompletionStage&lt;out T&gt;,
      action: Consumer&lt;in T&gt;,
      executor: Executor
    ): CompletionStage&lt;Void&gt; {
<span class="nc" id="L680">      return stage.acceptEitherAsync(other, action, executor)</span>
    }

    /** @inheritDoc
     */
    override fun runAfterEither(other: CompletionStage&lt;*&gt;?, action: Runnable): CompletionStage&lt;Void&gt; {
<span class="nc" id="L686">      return stage.runAfterEither(other, action)</span>
    }

    /** @inheritDoc
     */
    override fun runAfterEitherAsync(other: CompletionStage&lt;*&gt;?, action: Runnable): CompletionStage&lt;Void&gt; {
<span class="nc" id="L692">      return stage.runAfterEitherAsync(other, action)</span>
    }

    /** @inheritDoc
     */
    override fun runAfterEitherAsync(
      other: CompletionStage&lt;*&gt;?,
      action: Runnable,
      executor: Executor
    ): CompletionStage&lt;Void&gt; {
<span class="nc" id="L702">      return stage.runAfterEitherAsync(other, action, executor)</span>
    }

    /** @inheritDoc
     */
    override fun &lt;U&gt; thenCompose(fn: Function&lt;in T, out CompletionStage&lt;U&gt;&gt;): CompletionStage&lt;U&gt; {
<span class="nc" id="L708">      return stage.thenCompose(fn)</span>
    }

    /** @inheritDoc
     */
    override fun &lt;U&gt; thenComposeAsync(fn: Function&lt;in T, out CompletionStage&lt;U&gt;&gt;): CompletionStage&lt;U&gt; {
<span class="nc" id="L714">      return stage.thenComposeAsync(fn)</span>
    }

    /** @inheritDoc
     */
    override fun &lt;U&gt; thenComposeAsync(
      fn: Function&lt;in T, out CompletionStage&lt;U&gt;&gt;,
      executor: Executor
    ): CompletionStage&lt;U&gt; {
<span class="nc" id="L723">      return stage.thenComposeAsync(fn, executor)</span>
    }

    /** @inheritDoc
     */
    override fun &lt;U&gt; handle(fn: BiFunction&lt;in T, Throwable, out U&gt;): CompletionStage&lt;U&gt; {
<span class="nc" id="L729">      return stage.handle(fn)</span>
    }

    /** @inheritDoc
     */
    override fun &lt;U&gt; handleAsync(fn: BiFunction&lt;in T, Throwable, out U&gt;): CompletionStage&lt;U&gt; {
<span class="nc" id="L735">      return stage.handleAsync(fn)</span>
    }

    /** @inheritDoc
     */
    override fun &lt;U&gt; handleAsync(
      fn: BiFunction&lt;in T, Throwable, out U&gt;,
      executor: Executor
    ): CompletionStage&lt;U&gt; {
<span class="nc" id="L744">      return stage.handleAsync(fn, executor)</span>
    }

    /** @inheritDoc
     */
    override fun whenComplete(action: BiConsumer&lt;in T, in Throwable&gt;): CompletionStage&lt;T&gt; {
<span class="nc" id="L750">      return stage.whenComplete(action)</span>
    }

    /** @inheritDoc
     */
    override fun whenCompleteAsync(action: BiConsumer&lt;in T, in Throwable&gt;): CompletionStage&lt;T&gt; {
<span class="nc" id="L756">      return stage.whenCompleteAsync(action)</span>
    }

    /** @inheritDoc
     */
    override fun whenCompleteAsync(
      action: BiConsumer&lt;in T, in Throwable&gt;,
      executor: Executor
    ): CompletionStage&lt;T&gt; {
<span class="nc" id="L765">      return stage.whenCompleteAsync(action, executor)</span>
    }

    /** @inheritDoc
     */
    override fun exceptionally(fn: Function&lt;Throwable, out T&gt;): CompletionStage&lt;T&gt; {
<span class="nc" id="L771">      return stage.exceptionally(fn)</span>
    }

    /** @inheritDoc
     */
    override fun toCompletableFuture(): CompletableFuture&lt;T&gt; {
<span class="nc" id="L777">      return stage.toCompletableFuture()</span>
    }

    /**
     * Models a Reactive Java [Subscription], which is responsible for propagating events from a
     * Concurrent Java [CompletableFuture] to a [Subscriber].
     *
     *
     * This object is generally used internally by the [CompletableFuturePublisher], once a [Subscriber]
     * attaches itself to a [Publisher] that is actually a wrapped [CompletableFuture]. Error (exception)
     * events and value events are both propagated. Subscribers based on this wrapping will only ever receive a maximum
     * of **one value** or **one error**.
     */
<span class="nc" id="L790">    @Immutable</span>
    @ThreadSafe
<span class="nc" id="L792">    public inner class CompletableFutureSubscription internal constructor(</span>
      future: CompletableFuture&lt;T&gt;,
      subscriber: Subscriber&lt;in T&gt;?,
      executor: Executor
    ) : Subscription {
<span class="nc" id="L797">      private val completed = AtomicBoolean(false)</span>
      private val subscriber: Subscriber&lt;in T&gt;
      private val future: CompletableFuture&lt;T&gt;
      private val executor: Executor

      /**
       * Private constructor, meant for use by `CompletableFuturePublisher` only.
       */
<span class="nc" id="L805">      init {</span>
<span class="nc" id="L806">        this.future = Objects.requireNonNull(future)</span>
<span class="nc" id="L807">        this.subscriber = Objects.requireNonNull(subscriber)!!</span>
<span class="nc" id="L808">        this.executor = Objects.requireNonNull(executor)</span>
<span class="nc" id="L809">      }</span>

      /**
       * Request the specified number of items from the underlying [Subscription]. This must **always be
       * &lt;pre&gt;1&lt;/pre&gt;**.
       *
       * @param n Number of elements to request to the upstream (must always be &lt;pre&gt;1&lt;/pre&gt;).
       * @throws IllegalArgumentException If any value other than &lt;pre&gt;1&lt;/pre&gt; is passed in.
       */
      @Synchronized
      @Suppress(&quot;TooGenericExceptionCaught&quot;)
      override fun request(n: Long) {
<span class="nc bnc" id="L821" title="All 4 branches missed.">        if (n == 1L &amp;&amp; !completed.get()) {</span>
<span class="nc" id="L822">          try {</span>
<span class="nc" id="L823">            val future = this.future</span>
<span class="nc" id="L824">            future.thenAcceptAsync({</span>
<span class="nc" id="L825">              var value: T? = null</span>
<span class="nc" id="L826">              var err: Throwable? = null</span>
<span class="nc" id="L827">              try {</span>
<span class="nc" id="L828">                value = future.get()</span>
<span class="nc" id="L829">              } catch (exc: Exception) {</span>
<span class="nc" id="L830">                err = exc</span>
              }
<span class="nc bnc" id="L832" title="All 2 branches missed.">              if (completed.compareAndSet(false, true)) {</span>
<span class="nc bnc" id="L833" title="All 2 branches missed.">                if (err != null) {</span>
<span class="nc" id="L834">                  subscriber.onError(err)</span>
                } else {
<span class="nc bnc" id="L836" title="All 2 branches missed.">                  if (value != null) {</span>
<span class="nc" id="L837">                    subscriber.onNext(value)</span>
                  }
<span class="nc" id="L839">                  subscriber.onComplete()</span>
                }
              }
<span class="nc" id="L842">            }, executor)</span>
<span class="nc" id="L843">          } catch (e: Exception) {</span>
<span class="nc" id="L844">            subscriber.onError(e)</span>
          }
<span class="nc bnc" id="L846" title="All 2 branches missed.">        } else if (n != 1L) {</span>
<span class="nc" id="L847">          val ex = IllegalArgumentException(</span>
<span class="nc" id="L848">            &quot;Cannot request more or less than 1 item from a ReactiveFuture-wrapped publisher.&quot;</span>
          )
<span class="nc" id="L850">          subscriber.onError(ex)</span>
        }
<span class="nc" id="L852">      }</span>

      /**
       * Request the publisher to stop sending data and clean up resources.
       */
      @Synchronized
      override fun cancel() {
<span class="nc bnc" id="L859" title="All 2 branches missed.">        if (completed.compareAndSet(false, true)) {</span>
<span class="nc" id="L860">          subscriber.onComplete()</span>
<span class="nc" id="L861">          future.cancel(false)</span>
        }
<span class="nc" id="L863">      }</span>
    }
  }

  /**
   * Structure that adapts Guava's [ListenableFuture] to a Reactive Java [Publisher], which publishes one
   * item - either the result of the computation, or an error.
   *
   *
   * This object is used in the specific circumstance that a [ListenableFuture] is wrapped by a
   * [ReactiveFuture], and then used within the Reactive Java ecosystem as a [Publisher]. We simply set a
   * callback for the future value, upon item-request (one cycle is allowed), and propagate any events received to the
   * publisher.
   *
   * @param &lt;T&gt; Emit type for this adapter. Matches the publisher it wraps.
  &lt;/T&gt; */
<span class="nc" id="L879">  public class ListenableFuturePublisher&lt;T&gt;</span>
  /**
   * Wrap a [ListenableFuture]. Private constructor for use by [ReactiveFuture] only.
   *
   * @param future The future to convert or wait on.
   * @param callbackExecutor Executor to run the callback on.
<span class="nc" id="L885">   */ internal constructor(</span>
<span class="nc" id="L886">    @field:Nonnull</span>
    @param:Nonnull
    private val future: ListenableFuture&lt;T&gt;,

<span class="nc" id="L890">    @field:Nonnull</span>
    @param:Nonnull
    private val callbackExecutor: Executor
  ) : Publisher&lt;T&gt; {
    override fun subscribe(subscriber: Subscriber&lt;in T&gt;) {
<span class="nc" id="L895">      Objects.requireNonNull(subscriber, &quot;Subscriber cannot be null&quot;)</span>
<span class="nc" id="L896">      subscriber.onSubscribe(</span>
<span class="nc" id="L897">        ListenableFutureSubscription(</span>
<span class="nc" id="L898">          future,</span>
<span class="nc" id="L899">          subscriber,</span>
<span class="nc" id="L900">          callbackExecutor,</span>
        )
      )
<span class="nc" id="L903">    }</span>

    /**
     * Models a Reactive Java [Subscription], which is responsible for propagating events from a
     * [ListenableFuture] to a [Subscriber].
     *
     *
     * This object is generally used internally by the [ListenableFuturePublisher], once a [Subscriber]
     * attaches itself to a [Publisher] that is actually a wrapped [ListenableFuture]. Error (exception)
     * events and value events are both propagated. Subscribers based on this wrapping will only ever receive a maximum
     * of **one value** or **one error**.
     */
<span class="nc" id="L915">    @Immutable</span>
    @ThreadSafe
<span class="nc" id="L917">    public inner class ListenableFutureSubscription internal constructor(</span>
      future: ListenableFuture&lt;T&gt;,
      subscriber: Subscriber&lt;in T&gt;?,
      executor: Executor
    ) : Subscription {
<span class="nc" id="L922">      private val completed = AtomicBoolean(false)</span>
      private val subscriber: Subscriber&lt;in T&gt;

      // to allow cancellation
      private val future: ListenableFuture&lt;T&gt;

      // executor to use when dispatching the callback
      private val executor: Executor

      /**
       * Private constructor, meant for use by `ListenableFuturePublisher` only.
       */
<span class="nc" id="L934">      init {</span>
<span class="nc" id="L935">        this.future = Objects.requireNonNull(future)</span>
<span class="nc" id="L936">        this.subscriber = Objects.requireNonNull(subscriber)!!</span>
<span class="nc" id="L937">        this.executor = Objects.requireNonNull(executor)</span>
<span class="nc" id="L938">      }</span>

      /**
       * Request the specified number of items from the underlying [Subscription]. This must **always be
       * &lt;pre&gt;1&lt;/pre&gt;**.
       *
       * @param n Number of elements to request to the upstream (must always be &lt;pre&gt;1&lt;/pre&gt;).
       * @throws IllegalArgumentException If any value other than &lt;pre&gt;1&lt;/pre&gt; is passed in.
       */
      @Synchronized
      @Suppress(&quot;TooGenericExceptionCaught&quot;)
      override fun request(n: Long) {
<span class="nc bnc" id="L950" title="All 4 branches missed.">        if (n == 1L &amp;&amp; !completed.get()) {</span>
<span class="nc" id="L951">          try {</span>
<span class="nc" id="L952">            val future = this.future</span>
<span class="nc" id="L953">            future.addListener({</span>
<span class="nc" id="L954">              var value: T? = null</span>
<span class="nc" id="L955">              var err: Throwable? = null</span>
<span class="nc" id="L956">              try {</span>
<span class="nc" id="L957">                value = this.future.get()</span>
<span class="nc" id="L958">              } catch (exc: Exception) {</span>
<span class="nc" id="L959">                err = exc</span>
              }
<span class="nc bnc" id="L961" title="All 2 branches missed.">              if (completed.compareAndSet(false, true)) {</span>
<span class="nc bnc" id="L962" title="All 2 branches missed.">                if (err != null) {</span>
<span class="nc" id="L963">                  subscriber.onError(err)</span>
                } else {
<span class="nc bnc" id="L965" title="All 2 branches missed.">                  if (value != null) {</span>
<span class="nc" id="L966">                    subscriber.onNext(value)</span>
                  }
<span class="nc" id="L968">                  subscriber.onComplete()</span>
                }
              }
<span class="nc" id="L971">            }, executor)</span>
<span class="nc" id="L972">          } catch (e: Exception) {</span>
<span class="nc" id="L973">            subscriber.onError(e)</span>
          }
<span class="nc bnc" id="L975" title="All 2 branches missed.">        } else if (n != 1L) {</span>
<span class="nc" id="L976">          val ex = IllegalArgumentException(</span>
<span class="nc" id="L977">            &quot;Cannot request more or less than 1 item from a ReactiveFuture-wrapped publisher.&quot;</span>
          )
<span class="nc" id="L979">          subscriber.onError(ex)</span>
        }
<span class="nc" id="L981">      }</span>

      /**
       * Request the publisher to stop sending data and clean up resources.
       */
      @Synchronized
      override fun cancel() {
<span class="nc bnc" id="L988" title="All 2 branches missed.">        if (completed.compareAndSet(false, true)) {</span>
<span class="nc" id="L989">          subscriber.onComplete()</span>
<span class="nc" id="L990">          future.cancel(false)</span>
        }
<span class="nc" id="L992">      }</span>
    }
  }

  public companion object {
    // -- Public API -- //
    /**
     * Wrap a Reactive Java [Publisher] in a universal [ReactiveFuture], such that it may be used with any
     * interface requiring a supported async or future value.
     *
     * The resulting object is usable as any of [ListenableFuture], [Publisher], or [ApiFuture]. See
     * class docs for more information.
     *
     * **Note:** to use a [Publisher] as a [Future] (or any descendent thereof), the [Publisher]
     * may only emit one value, and no more. Emitting multiple items is considered an error when wrapped in this class
     * and accessed as a [Future], to prevent silently dropping intermediate values on the floor.
     *
     * @param publisher Reactive publisher to wrap.
     * @param R Return or emission type of the publisher.
     * @return Wrapped reactive future object.
     * @throws IllegalArgumentException If the passed `publisher` is `null`.
     */
    public fun &lt;R&gt; wrap(publisher: Publisher&lt;R&gt;?): ReactiveFuture&lt;R&gt; {
<span class="nc bnc" id="L1015" title="All 2 branches missed.">      requireNotNull(publisher) { &quot;Cannot wrap `null` publisher.&quot; }</span>
<span class="nc" id="L1016">      return ReactiveFuture(publisher)</span>
    }

    /**
     * Wrap a regular Java [CompletableFuture] in a universal [ReactiveFuture], such that it may be used with
     * any interface requiring support for that class.
     *
     * The resulting object is usable as any of [ListenableFuture], [Publisher], or [ApiFuture]. See
     * class docs for more information.
     *
     * **Note:** to use a [Publisher] as a [Future] (or any descendent thereof), the [Publisher]
     * may only emit one value, and no more. Emitting multiple items is considered an error when wrapped in this class
     * and accessed as a [Future], to prevent silently dropping intermediate values on the floor.
     *
     * **Warning:** this method uses [MoreExecutors.directExecutor] for callback execution. You should only
     * do this if the callbacks associated with your future are lightweight and exit quickly. Otherwise, it is heavily
     * recommended to use the variants of `wrap` that accept an [Executor]. For instance, the corresponding
     * method to this one is [.wrap].
     *
     * @param future Completable future to wrap.
     * @param R Return or emission type of the future.
     * @return Wrapped reactive future object.
     */
    public fun &lt;R&gt; wrap(future: CompletableFuture&lt;R&gt;?): ReactiveFuture&lt;R&gt; {
<span class="nc bnc" id="L1040" title="All 2 branches missed.">      requireNotNull(future) { &quot;Cannot wrap `null` publisher.&quot; }</span>
<span class="nc" id="L1041">      return wrap(future, MoreExecutors.directExecutor())</span>
    }

    /**
     * Wrap a regular Java [CompletableFuture] in a universal [ReactiveFuture], such that it may be used with
     * any interface requiring support for that class.
     *
     * The resulting object is usable as any of [ListenableFuture], [Publisher], or [ApiFuture]. See
     * class docs for more information.
     *
     * **Note:** to use a [Publisher] as a [Future] (or any descendent thereof), the [Publisher]
     * may only emit one value, and no more. Emitting multiple items is considered an error when wrapped in this class
     * and accessed as a [Future], to prevent silently dropping intermediate values on the floor.
     *
     * @param future Completable future to wrap.
     * @param executor Executor to use.
     * @param R Return or emission type of the future.
     * @return Wrapped reactive future object.
     */
    public fun &lt;R&gt; wrap(future: CompletableFuture&lt;R&gt;?, executor: Executor?): ReactiveFuture&lt;R&gt; {
<span class="nc bnc" id="L1061" title="All 2 branches missed.">      requireNotNull(future) { &quot;Cannot wrap `null` future.&quot; }</span>
<span class="nc bnc" id="L1062" title="All 2 branches missed.">      requireNotNull(executor) { &quot;Cannot wrap future with `null` executor.&quot; }</span>
<span class="nc" id="L1063">      return ReactiveFuture(future, executor)</span>
    }

    /**
     * Wrap a Guava [ListenableFuture] in a universal [ReactiveFuture], such that it may be used with any
     * interface requiring a supported async or future value.
     *
     * **Warning:** this method uses [MoreExecutors.directExecutor] for callback execution. You should only
     * do this if the callbacks associated with your future are lightweight and exit quickly. Otherwise, it is heavily
     * recommended to use the variants of `wrap` that accept an [Executor]. For instance, the corresponding
     * method to this one is [.wrap].
     *
     * The resulting object is usable as any of [ListenableFuture], [Publisher], or [ApiFuture]. See
     * class docs for more information.
     *
     * **Note:** to use a [Publisher] as a [Future] (or any descendent thereof), the [Publisher]
     * may only emit one value, and no more. Emitting multiple items is considered an error when wrapped in this class
     * and accessed as a [Future], to prevent silently dropping intermediate values on the floor.
     *
     * @param future Future value to wrap.
     * @param R Return value type for the future.
     * @return Wrapped reactive future object.
     * @throws IllegalArgumentException If the passed `future` is `null`.
     */
    public fun &lt;R&gt; wrap(future: ListenableFuture&lt;R&gt;?): ReactiveFuture&lt;R&gt; {
<span class="nc" id="L1088">      return wrap(future, MoreExecutors.directExecutor())</span>
    }

    /**
     * Wrap a Guava [ListenableFuture] in a universal [ReactiveFuture], such that it may be used with any
     * interface requiring a supported async or future value.
     *
     * The resulting object is usable as any of [ListenableFuture], [Publisher], or [ApiFuture]. See
     * class docs for more information.
     *
     * **Note:** to use a [Publisher] as a [Future] (or any descendent thereof), the [Publisher]
     * may only emit one value, and no more. Emitting multiple items is considered an error when wrapped in this class
     * and accessed as a [Future], to prevent silently dropping intermediate values on the floor.
     *
     * @param future Future value to wrap.
     * @param executor Executor to dispatch callbacks with.
     * @param R Return value type for the future.
     * @return Wrapped reactive future object.
     * @throws IllegalArgumentException If the passed `future` is `null`.
     */
    public fun &lt;R&gt; wrap(future: ListenableFuture&lt;R&gt;?, executor: Executor?): ReactiveFuture&lt;R&gt; {
<span class="nc bnc" id="L1109" title="All 2 branches missed.">      requireNotNull(future) { &quot;Cannot wrap `null` future.&quot; }</span>
<span class="nc bnc" id="L1110" title="All 2 branches missed.">      requireNotNull(executor) { &quot;Cannot wrap future with `null` executor.&quot; }</span>
<span class="nc" id="L1111">      return ReactiveFuture(future, executor)</span>
    }

    /**
     * Wrap a Google APIs [ApiFuture] in a universal [ReactiveFuture], such that it may be used with any
     * interface requiring a supported async or future value.
     *
     * The resulting object is usable as any of [ListenableFuture], [Publisher], or [ApiFuture]. See
     * class docs for more information.
     *
     * **Note:** to use a [Publisher] as a [Future] (or any descendent thereof), the [Publisher]
     * may only emit one value, and no more. Emitting multiple items is considered an error when wrapped in this class
     * and accessed as a [Future], to prevent silently dropping intermediate values on the floor.
     *
     * @param apiFuture API future to wrap.
     * @param executor Executor to run callbacks with.
     * @param R Return value type for the future.
     * @return Wrapped reactive future object.
     * @throws IllegalArgumentException If the passed `apiFuture` is `null`.
     */
    public fun &lt;R&gt; wrap(apiFuture: ApiFuture&lt;R&gt;?, executor: Executor?): ReactiveFuture&lt;R&gt; {
<span class="nc bnc" id="L1132" title="All 2 branches missed.">      requireNotNull(apiFuture) { &quot;Cannot wrap `null` API future.&quot; }</span>
<span class="nc" id="L1133">      return wrap(ApiFutureToListenableFuture(apiFuture), executor)</span>
    }

    /**
     * Wrap a Google APIs [ApiFuture] in a universal [ReactiveFuture], such that it may be used with any
     * interface requiring a supported async or future value.
     *
     * **Warning:** this method uses [MoreExecutors.directExecutor] for callback execution. You should only
     * do this if the callbacks associated with your future are lightweight and exit quickly. Otherwise, it is heavily
     * recommended to use the variants of `wrap` that accept an [Executor]. For instance, the corresponding
     * method to this one is [wrap].
     *
     * The resulting object is usable as any of [ListenableFuture], [Publisher], or [ApiFuture]. See
     * class docs for more information.
     *
     * **Note:** to use a [Publisher] as a [Future] (or any descendent thereof), the [Publisher]
     * may only emit one value, and no more. Emitting multiple items is considered an error when wrapped in this class
     * and accessed as a [Future], to prevent silently dropping intermediate values on the floor.
     *
     * @param apiFuture API future to wrap.
     * @param R Return value type for the future.
     * @return Wrapped reactive future object.
     * @throws IllegalArgumentException If the passed `apiFuture` is `null`.
     */
    public fun &lt;R&gt; wrap(apiFuture: ApiFuture&lt;R&gt;?): ReactiveFuture&lt;R&gt; {
<span class="nc" id="L1158">      return wrap(apiFuture, MoreExecutors.directExecutor())</span>
    }

    /**
     * Create an already-resolved future, wrapping the provided value. The future will present as done as soon as it is
     * returned from this method.
     *
     * Under the hood, this is simply a [ReactiveFuture] wrapping a call to
     * [Futures.immediateFuture].
     *
     * @param value Value to wrap in an already-completed future.
     * @param R Return value generic type.
     * @return Reactive future wrapping a finished value.
     */
    public fun &lt;R&gt; done(value: R): ReactiveFuture&lt;R&gt; {
<span class="nc" id="L1173">      return wrap(Futures.immediateFuture(value))</span>
    }

    /**
     * Create an already-failed future, wrapping the provided exception instance. The future will present as one as soon
     * as it is returned from this method.
     *
     *
     * Calling [Future.get] or [Future.get] on a failed future will surface the
     * associated exception where invocation occurs. Under the hood, this is simply a [ReactiveFuture] wrapping a
     * call to [Futures.immediateFailedFuture].
     *
     * @param error Error to wrap in an already-failed future.
     * @param R Return value generic type.
     * @return Reactive future wrapping a finished value.
     */
    public fun &lt;R&gt; failed(error: Throwable): ReactiveFuture&lt;R&gt; {
<span class="nc" id="L1190">      return wrap(Futures.immediateFailedFuture(error))</span>
    }

    /**
     * Create an already-cancelled future. The future will present as both done and cancelled as soon as it is returned
     * from this method.
     *
     * Under the hood, this is simply a [ReactiveFuture] wrapping a call to [Futures.immediateCancelledFuture].
     *
     * @param R Return value generic type.
     * @return Reactive future wrapping a cancelled operation.
     */
    public fun &lt;R&gt; cancelled(): ReactiveFuture&lt;R&gt; {
<span class="nc" id="L1203">      return wrap(Futures.immediateCancelledFuture())</span>
    }
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>
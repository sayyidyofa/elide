<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>JsRuntime.kt</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">reports</a> &gt; <a href="index.source.html" class="el_package">elide.runtime.graalvm</a> &gt; <span class="el_source">JsRuntime.kt</span></div><h1>JsRuntime.kt</h1><pre class="source lang-java linenums">package elide.runtime.graalvm

import com.google.common.annotations.VisibleForTesting
import com.google.common.util.concurrent.Futures
import com.google.common.util.concurrent.MoreExecutors
import elide.server.type.RequestState
import elide.server.util.ServerFlag
import elide.util.Hex
import io.micronaut.caffeine.cache.Cache
import io.micronaut.caffeine.cache.Caffeine
import io.micronaut.context.annotation.Context
import io.micronaut.context.annotation.Factory
import io.micronaut.core.annotation.ReflectiveAccess
import kotlinx.coroutines.Deferred
import kotlinx.coroutines.guava.asDeferred
import kotlinx.serialization.json.Json
import org.graalvm.polyglot.HostAccess
import org.graalvm.polyglot.Context as VMContext
import org.graalvm.polyglot.Source
import org.graalvm.polyglot.Value
import org.slf4j.LoggerFactory
import java.io.FileNotFoundException
import java.nio.charset.Charset
import java.nio.charset.StandardCharsets
import java.security.MessageDigest
import java.util.concurrent.Callable
import java.util.concurrent.ConcurrentSkipListMap
import java.util.concurrent.Executor
import java.util.concurrent.Executors
import java.util.concurrent.atomic.AtomicBoolean
import java.util.concurrent.atomic.AtomicReference
import com.google.common.util.concurrent.ListenableFuture as Future

/** JavaScript embedded runtime logic, for use on the JVM. */
<span class="fc" id="L35">@Suppress(&quot;MemberVisibilityCanBePrivate&quot;)</span>
<span class="fc" id="L36">@Context public class JsRuntime {</span>
  public companion object {
    // Singleton instance.
<span class="fc" id="L39">    private val singleton = JsRuntime()</span>

    // Hard-coded JS VM options.
<span class="fc" id="L42">    private val baseOptions : List&lt;JSVMProperty&gt; = listOf(</span>
<span class="fc" id="L43">      StaticProperty(&quot;js.strict&quot;, &quot;true&quot;),</span>
    )

    // Options which can be controlled via user-configured inputs.
<span class="fc" id="L47">    private val configurableOptions : List&lt;JSVMProperty&gt; = listOf(</span>
<span class="fc" id="L48">      RuntimeProperty(&quot;vm.js.ecma&quot;, &quot;js.ecmascript-version&quot;, &quot;2020&quot;),</span>
    )

    // Options which must be evaluated at the time a context is created.
<span class="fc" id="L52">    private val conditionalOptions : List&lt;JSVMProperty&gt; = listOf(</span>
<span class="fc" id="L53">      ConditionalMultiProperty(main = ConditionalProperty(</span>
<span class="fc" id="L54">        &quot;vm.inspect&quot;,</span>
<span class="fc" id="L55">        &quot;inspect&quot;,</span>
<span class="nc" id="L56">        { ServerFlag.inspect },</span>
<span class="fc" id="L57">        defaultValue = &quot;false&quot;</span>
<span class="fc" id="L58">      ), properties = listOf(</span>
        // Inspection: Path.
<span class="pc" id="L60">        RuntimeProperty(&quot;vm.inspect.path&quot;, &quot;inspect.Path&quot;) { ServerFlag.inspectPath },</span>

        // Inspection: Suspend.
<span class="fc" id="L63">        RuntimeProperty(&quot;vm.inspect.suspend&quot;, &quot;inspect.Suspend&quot;, &quot;true&quot;),</span>

        // Inspection: Secure.
<span class="fc" id="L66">        RuntimeProperty(&quot;vm.inspect.secure&quot;, &quot;inspect.Secure&quot;, &quot;false&quot;) {</span>
<span class="nc" id="L67">          ServerFlag.inspectSecure.toString()</span>
        },

        // Inspection: Wait for debugger.
<span class="fc" id="L71">        RuntimeProperty(&quot;vm.inspect.wait&quot;, &quot;inspect.WaitAttached&quot;, &quot;false&quot;),</span>

        // Inspection: Runtime sources.
<span class="fc" id="L74">        RuntimeProperty(&quot;vm.inspect.internal&quot;, &quot;inspect.Internal&quot;, &quot;false&quot;),</span>
      )),
    )

    /** Runnable task within a JS VM context. */
<span class="nc" id="L79">    private class VMExecution&lt;R&gt; constructor (</span>
<span class="nc" id="L80">      val op: (VMContext) -&gt; R,</span>
<span class="nc" id="L81">      val result: AtomicReference&lt;R?&gt; = AtomicReference(null),</span>
    ): Runnable, Callable&lt;R&gt; {
      override fun run() {
<span class="nc" id="L84">        result.set(</span>
<span class="nc" id="L85">          ManagedContext.acquire().exec(op)</span>
        )
<span class="nc" id="L87">      }</span>

      override fun call(): R? {
<span class="nc" id="L90">        result.set(</span>
<span class="nc" id="L91">          ManagedContext.acquire().exec(op)</span>
        )
<span class="nc" id="L93">        return result.get()</span>
      }
<span class="nc" id="L95">    }</span>

    /** Dedicated executor for the JS Runtime. */
<span class="nc" id="L98">    internal class RuntimeExecutor {</span>
      // Dedicated thread executor backing the runtime.
<span class="nc" id="L100">      private val threadPool: Executor = Executors.newSingleThreadExecutor()</span>

      internal fun &lt;R&gt; submit(runnable: (VMContext) -&gt; R): Future&lt;R&gt; {
<span class="nc" id="L103">        val task = VMExecution(runnable)</span>
<span class="nc" id="L104">        return Futures.submit&lt;R&gt;(task) {</span>
<span class="nc" id="L105">          threadPool.execute(it)</span>
<span class="nc" id="L106">        }</span>
      }
    }

    /** @return Static acquisition of the singleton JavaScript runtime. */
<span class="fc" id="L111">    @JvmStatic public fun acquire(): JsRuntime = singleton</span>

    /** @return Set of options to apply to a new JS VM context. */
    @JvmStatic private fun buildRuntimeOptions(): Map&lt;JSVMProperty, String?&gt; {
<span class="nc" id="L115">      return baseOptions.plus(</span>
<span class="nc" id="L116">        configurableOptions</span>
<span class="nc" id="L117">      ).plus(</span>
<span class="nc" id="L118">        conditionalOptions</span>
<span class="nc" id="L119">      ).map {</span>
<span class="nc" id="L120">        it to it.value()</span>
<span class="nc" id="L121">      }.filter {</span>
<span class="nc bnc" id="L122" title="All 4 branches missed.">        it.second?.isNotBlank() ?: false</span>
<span class="nc" id="L123">      }.toMap()</span>
    }

    /** @return SDK VM context pre-built for JavaScript execution. */
    @JvmStatic @Factory private fun spawnContext(): VMContext {
<span class="nc" id="L128">      val logging = LoggerFactory.getLogger(JsRuntime::class.java)</span>
<span class="nc" id="L129">      val builder = VMContext.newBuilder(&quot;js&quot;)</span>
<span class="nc" id="L130">        .allowExperimentalOptions(true)</span>
<span class="nc" id="L131">        .allowValueSharing(true)</span>

<span class="nc" id="L133">      buildRuntimeOptions().flatMap {</span>
<span class="nc" id="L134">        val prop = it.key</span>
<span class="nc" id="L135">        val value = prop.value()</span>
<span class="nc bnc" id="L136" title="All 4 branches missed.">        if (value != null &amp;&amp; value != &quot;false&quot;) {</span>
<span class="nc bnc" id="L137" title="All 2 branches missed.">          if (prop is ConditionalMultiProperty) {</span>
            // if it's a multi-property, explode into the individual property values.
<span class="nc" id="L139">            prop.explode()</span>
          } else {
            // otherwise, just consider the single value.
<span class="nc" id="L142">            listOf(prop)</span>
          }
        } else {
          // if there's no value for this property, then we don't need to consider it.
<span class="nc" id="L146">          emptyList()</span>
        }
<span class="nc" id="L148">      }.forEach { prop -&gt;</span>
<span class="nc" id="L149">        val value = prop.value()</span>
<span class="nc bnc" id="L150" title="All 4 branches missed.">        if (value != null &amp;&amp; value != &quot;false&quot;) {</span>
<span class="nc" id="L151">          logging.debug(</span>
<span class="nc" id="L152">            &quot;Setting JS VM property: '$prop': '$value'&quot;</span>
          )
<span class="nc" id="L154">          builder.option(</span>
<span class="nc" id="L155">            prop.symbol,</span>
<span class="nc" id="L156">            value</span>
          )
          // special case: handle inspection
        }
<span class="nc" id="L160">      }</span>
<span class="nc" id="L161">      return builder.build()</span>
    }
  }

  /** Describes inputs to be made available during a VM execution. */
<span class="nc" id="L166">  public class ExecutionInputs&lt;State : Any&gt; public constructor(</span>
<span class="nc" id="L167">    public val data: Map&lt;String, Any?&gt; = ConcurrentSkipListMap(),</span>
  ) {
    public companion object {
      /** Key where shared state is placed in the execution input data map. */
      public const val STATE: String = &quot;_state_&quot;

      /** Key where combined state is placed in the execution input data map. */
      public const val CONTEXT: String = &quot;_ctx_&quot;

      // Shortcut for empty inputs.
<span class="nc" id="L177">      public val EMPTY: ExecutionInputs&lt;Any&gt; = ExecutionInputs()</span>

      /** @return Execution inputs from the provided request state object. */
      @JvmStatic public fun &lt;State : Any&gt; fromRequestState(
        context: RequestState,
        state: State?,
      ): ExecutionInputs&lt;State&gt; {
<span class="nc" id="L184">        return ExecutionInputs(mapOf(</span>
<span class="nc" id="L185">          STATE to state,</span>
<span class="nc" id="L186">          CONTEXT to context,</span>
        ))
      }
    }

    // Build the execution inputs into a set of arguments for the program.
    internal fun buildArguments(): Array&lt;out Any?&gt; {
<span class="nc" id="L193">      return arrayOf(this)</span>
    }

    /**
     * Host access to fetch the current state; if no state is available, `null` is returned.
     *
     * The &quot;state&quot; for an execution is modeled by the developer, via a serializable data class. If state is provided,
     * then it is made available to the JavaScript context.
     *
     * @return Instance of execution state provided at invocation time, or `null`.
     */
    @Suppress(&quot;UNCHECKED_CAST&quot;)
    @HostAccess.Export
    @ReflectiveAccess
    public fun state(): State? {
<span class="nc bnc" id="L208" title="All 2 branches missed.">      return data[STATE] as? State</span>
    }

    /**
     * Host access to fetch the current context; if no execution context is available, `null` is returned.
     *
     * The &quot;context&quot; is modeled by the [RequestState] class, which provides a consistent structure with guest language
     * accessors for notable context properties, such as the active HTTP request.
     *
     * @return Instance of execution context provided at invocation time, or `null`.
     */
    @HostAccess.Export
    @ReflectiveAccess
    public fun context(): RequestState? {
<span class="nc bnc" id="L222" title="All 2 branches missed.">      return data[CONTEXT] as? RequestState</span>
    }
<span class="nc" id="L224">  }</span>

  /** Abstract base interface for a JS VM property. */
  internal sealed interface JSVMProperty {
    /** Symbol to use for this property with the JS VM. */
    val symbol: String

    /** @return Resolved value for this property. */
    fun value(): String?
  }

  /**
   * Represents a hard-coded JS Runtime property.
   *
   * @param symbol Symbol to use for the VM property when passing it to a new context.
   * @param staticValue Value for this property.
   */
<span class="fc" id="L241">  internal data class StaticProperty(</span>
<span class="pc" id="L242">    override val symbol: String,</span>
<span class="pc" id="L243">    val staticValue: String,</span>
  ): JSVMProperty {
<span class="nc" id="L245">    override fun value(): String = staticValue</span>
  }

  /**
   * Represents a user-configurable JS Runtime property; binds a JS VM property to an Elide configuration property.
   *
   * @param name Name of the property within Elide's configuration system.
   * @param symbol Symbol to use for the VM property when passing it to a new context.
   * @param defaultValue If no configured value is available, this value should be passed instead. If null, pass no
   *   value at all.
   */
<span class="fc" id="L256">  internal data class RuntimeProperty(</span>
<span class="fc" id="L257">    private val name: String,</span>
<span class="pc" id="L258">    override val symbol: String,</span>
<span class="fc" id="L259">    private val defaultValue: String? = null,</span>
<span class="fc" id="L260">    private val getter: (() -&gt; String?)? = null,</span>
  ): JSVMProperty {
    // @TODO(sgammon): implement
<span class="nc bnc" id="L263" title="All 4 branches missed.">    override fun value(): String? = getter?.invoke() ?: defaultValue</span>
<span class="fc" id="L264">  }</span>

  /**
   * Represents a property for the JS Runtime which applies based on some [condition], or falls back to a [defaultValue]
   * at a given [name] in Elide's configuration system.
   *
   * @param name Name of the property within Elide's configuration system.
   * @param symbol Symbol to use for the VM property when passing it to a new context.
   * @param condition Function to execute to determine whether this property should be applied.
   * @param value Runtime value bound to this property, if applicable; otherwise, just pass a [defaultValue].
   * @param defaultValue If the value is disabled, this value should be passed instead. If null, pass no value at all.
   */
<span class="fc" id="L276">  internal data class ConditionalProperty(</span>
<span class="fc" id="L277">    private val name: String,</span>
<span class="pc" id="L278">    override val symbol: String,</span>
<span class="fc" id="L279">    private val condition: () -&gt; Boolean,</span>
<span class="fc" id="L280">    private val value: RuntimeProperty? = null,</span>
<span class="pc" id="L281">    private val defaultValue: String? = null,</span>
  ): JSVMProperty {
<span class="nc bnc" id="L283" title="All 2 branches missed.">    override fun value(): String = if (condition.invoke()) {</span>
<span class="nc bnc" id="L284" title="All 4 branches missed.">      value?.value() ?: &quot;true&quot;</span>
    } else {
<span class="nc bnc" id="L286" title="All 2 branches missed.">      defaultValue ?: &quot;false&quot;</span>
<span class="nc" id="L287">    }</span>
<span class="fc" id="L288">  }</span>

  /**
   * Represents a property for the JS Runtime which applies based on some `condition`, or falls back to a `defaultValue`
   * at a given `name` in Elide's configuration system; this is similar to a [ConditionalProperty], but allows for
   * multiple properties to be efficiently applied based on a single condition.
   *
   * @param main Conditional property which should trigger this set of properties.
   * @param properties Other property configurations which should apply if this one applies.
   */
<span class="fc" id="L298">  internal data class ConditionalMultiProperty(</span>
<span class="fc" id="L299">    private val main: ConditionalProperty,</span>
<span class="fc" id="L300">    private val properties: List&lt;RuntimeProperty&gt;,</span>
  ): JSVMProperty {
    /** @return Main value for this conditional multi-property set. */
<span class="nc" id="L303">    override fun value(): String = main.value()</span>

    /** @return Main property symbol for this conditional multi-property set. */
<span class="nc" id="L306">    override val symbol: String get() = main.symbol</span>

    /** @return Full list of properties that should apply for this set, including the root property. */
    internal fun explode(): List&lt;JSVMProperty&gt; {
<span class="nc" id="L310">      return listOf(</span>
<span class="nc" id="L311">        main</span>
<span class="nc" id="L312">      ).plus(</span>
<span class="nc" id="L313">        properties</span>
      )
    }
  }

  /** Shortcuts for creating script descriptors. */
  @Suppress(&quot;unused&quot;) public object Script {
    /** @return Embedded script container for the provided [path] (and [charset], defaulting to `UTF-8`). */
<span class="fc" id="L321">    @JvmStatic public fun embedded(</span>
      path: String,
<span class="fc" id="L323">      charset: Charset = StandardCharsets.UTF_8,</span>
<span class="fc" id="L324">      invocationBase: String? = null,</span>
<span class="fc" id="L325">      invocationTarget: String? = null,</span>
<span class="fc" id="L326">    ): EmbeddedScript = EmbeddedScript(</span>
<span class="fc" id="L327">      path = path,</span>
<span class="fc" id="L328">      charset = charset,</span>
<span class="fc" id="L329">      invocationBase = invocationBase,</span>
<span class="fc" id="L330">      invocationTarget = invocationTarget,</span>
<span class="fc" id="L331">    )</span>

    /** @return Literal script container for the provided [script]. */
<span class="nc" id="L334">    @JvmStatic public fun literal(</span>
      script: String,
      id: String,
<span class="nc" id="L337">      invocationBase: String? = null,</span>
<span class="nc" id="L338">      invocationTarget: String? = null,</span>
<span class="nc" id="L339">    ): ExecutableScript = LiteralScript(</span>
<span class="nc" id="L340">      id,</span>
<span class="nc" id="L341">      script,</span>
<span class="nc" id="L342">      invocationBase = invocationBase,</span>
<span class="nc" id="L343">      invocationTarget = invocationTarget,</span>
<span class="nc" id="L344">    )</span>
  }

  /** Managed GraalVM execution context, with thread guards. */
<span class="nc" id="L348">  private class ManagedContext {</span>
    companion object {
      @JvmStatic internal fun acquire(): ManagedContext {
<span class="nc" id="L351">        return context.get()</span>
      }

<span class="nc" id="L354">      private val context: ThreadLocal&lt;ManagedContext&gt; = object: ThreadLocal&lt;ManagedContext&gt;() {</span>
        override fun initialValue(): ManagedContext {
<span class="nc" id="L356">          val ctx = ManagedContext()</span>
<span class="nc" id="L357">          ctx.initialize()</span>
<span class="nc" id="L358">          return ctx</span>
        }
      }
    }

<span class="nc" id="L363">    private val initialized: AtomicBoolean = AtomicBoolean(false)</span>
<span class="nc" id="L364">    private val locked: AtomicBoolean = AtomicBoolean(false)</span>
<span class="nc" id="L365">    private val vmContext: AtomicReference&lt;VMContext?&gt; = AtomicReference(null)</span>

    private fun initialize() {
<span class="nc" id="L368">      initialized.compareAndSet(</span>
<span class="nc" id="L369">        false,</span>
<span class="nc" id="L370">        true,</span>
      )
<span class="nc" id="L372">      vmContext.compareAndSet(</span>
<span class="nc" id="L373">        null,</span>
<span class="nc" id="L374">        spawnContext(),</span>
      )
<span class="nc" id="L376">    }</span>

    // Acquire this context for execution.
    fun &lt;R&gt; exec(operation: (VMContext) -&gt; R): R {
<span class="nc" id="L380">      locked.compareAndSet(</span>
<span class="nc" id="L381">        false,</span>
<span class="nc" id="L382">        true,</span>
      )
<span class="nc bnc" id="L384" title="All 2 branches missed.">      val ctx = vmContext.get() ?: error(</span>
<span class="nc" id="L385">        &quot;Context not initialized, cannot execute on VM&quot;</span>
      )
<span class="nc" id="L387">      ctx.enter()</span>
<span class="nc" id="L388">      val result = operation.invoke(ctx)</span>
<span class="nc" id="L389">      ctx.leave()</span>
<span class="nc" id="L390">      locked.compareAndSet(</span>
<span class="nc" id="L391">        true,</span>
<span class="nc" id="L392">        false,</span>
      )
<span class="nc" id="L394">      return result</span>
    }
  }

  /** Script runtime manager. */
<span class="fc" id="L399">  internal class ScriptRuntime {</span>
    internal companion object {
      private const val embeddedRoot = &quot;embedded&quot;
      private const val manifest = &quot;/$embeddedRoot/runtime/runtime-js.json&quot;
<span class="fc" id="L403">      private val initialized: AtomicBoolean = AtomicBoolean(false)</span>

      // Runtime pre-amble from which to clone and splice executable scripts.
      private var preamble: StringBuilder

      // Runtime finalizer / loader function.
      private var loader: StringBuilder

<span class="fc" id="L411">      init {</span>
<span class="fc" id="L412">        val (p, l) = initialize()</span>
<span class="fc" id="L413">        preamble = p</span>
<span class="fc" id="L414">        loader = l</span>
<span class="fc" id="L415">      }</span>

      // Load a JS artifact for runtime use from the JAR.
      @JvmStatic private fun loadArtifact(path: String): String {
<span class="fc" id="L419">        return (</span>
<span class="pc bpc" id="L420" title="1 of 2 branches missed.">          JsRuntime::class.java.getResourceAsStream(&quot;/$embeddedRoot/runtime/$path&quot;) ?:</span>
<span class="nc" id="L421">            throw FileNotFoundException(&quot;Unable to locate runtime JS resource $path&quot;)</span>
<span class="pc bpc" id="L422" title="1 of 2 branches missed.">        ).bufferedReader(StandardCharsets.UTF_8).use {</span>
<span class="fc" id="L423">          it.readText()</span>
        }
      }

      // Initialize the script runtime by loading artifacts mentioned in the manifest.
      @JvmStatic @Synchronized private fun initialize(): Pair&lt;StringBuilder, StringBuilder&gt; {
<span class="pc bpc" id="L429" title="1 of 2 branches missed.">        if (!initialized.get()) {</span>
<span class="fc" id="L430">          initialized.compareAndSet(</span>
<span class="fc" id="L431">            false,</span>
<span class="fc" id="L432">            true</span>
          )

          // resolve the stream
<span class="pc bpc" id="L436" title="1 of 2 branches missed.">          val manifestStream = ScriptRuntime::class.java.getResourceAsStream(</span>
<span class="fc" id="L437">            manifest</span>
<span class="nc" id="L438">          ) ?: throw IllegalStateException(</span>
<span class="nc" id="L439">            &quot;Failed to resolve JS runtime manifest: '$manifest'. Please check that you have a dependency on &quot; +</span>
            &quot;'graalvm-js', which is required to run embedded SSR scripts.&quot;
          )

          // grab content
<span class="pc bpc" id="L444" title="1 of 2 branches missed.">          val manifestContent = manifestStream.bufferedReader().use { it.readText() }</span>

          // deserialize as script runtime config
<span class="fc" id="L447">          val config = Json.decodeFromString(</span>
<span class="fc" id="L448">            JsRuntimeConfig.serializer(),</span>
<span class="fc" id="L449">            manifestContent</span>
          )

          // load each resource
<span class="fc" id="L453">          val runtimePreamble = StringBuilder()</span>
<span class="fc" id="L454">          config.artifacts.map {</span>
<span class="fc" id="L455">            runtimePreamble.appendLine(loadArtifact(it.name))</span>
          }

          // load entrypoint
<span class="fc" id="L459">          val runtimeEntry = StringBuilder()</span>
<span class="pc bpc" id="L460" title="2 of 4 branches missed.">          if (config.entry.isNotBlank()) {</span>
<span class="fc" id="L461">            runtimeEntry.appendLine(loadArtifact(config.entry))</span>
          }

<span class="fc" id="L464">          return (</span>
<span class="fc" id="L465">            runtimePreamble to runtimeEntry</span>
          )
<span class="nc" id="L467">        } else error(</span>
<span class="nc" id="L468">          &quot;Cannot initialize JS runtime twice&quot;</span>
        )
      }
    }

    // Thread-pool executor where we should acquire execution contexts.
<span class="pc" id="L474">    internal val executor: RuntimeExecutor by lazy {</span>
<span class="nc" id="L475">      RuntimeExecutor()</span>
    }

    // Private cache of warmed sources.
<span class="fc" id="L479">    private val sourceCache: Cache&lt;ScriptID, Value&gt; = Caffeine.newBuilder()</span>
<span class="fc" id="L480">      .executor(MoreExecutors.directExecutor())</span>
<span class="fc" id="L481">      .build()</span>

    /** @return Executable [script] prepared with an entrypoint and runtime glue code. */
    private fun prepare(script: ExecutableScript): ExecutableScript {
<span class="nc" id="L485">      val content = script.load()</span>
<span class="nc" id="L486">      val container = StringBuilder()</span>
<span class="nc bnc" id="L487" title="All 2 branches missed.">      if (script.installShims) {</span>
<span class="nc" id="L488">        container.append(</span>
<span class="nc" id="L489">          preamble</span>
        )
      }
<span class="nc" id="L492">      container.append(</span>
<span class="nc" id="L493">        content</span>
      )
<span class="nc bnc" id="L495" title="All 2 branches missed.">      if (script.installEntry) {</span>
<span class="nc" id="L496">        container.append(</span>
<span class="nc" id="L497">          loader</span>
        )
      }
<span class="nc" id="L500">      script.assignRendered(</span>
<span class="nc" id="L501">        container</span>
      )
<span class="nc" id="L503">      return script</span>
    }

    /** @return Interpreted and warmed [script] -- in re-used form, or on the fly, as applicable. */
    internal fun resolve(script: ExecutableScript): Value {
<span class="nc" id="L508">      return sourceCache.get(script.fingerprint()) { _ -&gt;</span>
<span class="nc" id="L509">        val prepped = prepare(script)</span>
<span class="nc bnc" id="L510" title="All 2 branches missed.">        ManagedContext.acquire().exec {</span>
<span class="nc" id="L511">          it.eval(prepped.interpret())</span>
<span class="nc" id="L512">        } ?: error(</span>
<span class="nc" id="L513">          &quot;Failed to resolve value from VM execution: got `null`&quot;</span>
        )
      }!!
    }
  }

  /** Embedded script descriptor object. */
<span class="fc" id="L520">  public sealed class ExecutableScript(</span>
<span class="pc" id="L521">    internal val installShims: Boolean = true,</span>
<span class="pc" id="L522">    internal val installEntry: Boolean = true,</span>
<span class="pc" id="L523">    internal val invocationBase: String? = null,</span>
<span class="pc" id="L524">    internal val invocationTarget: String? = null,</span>
<span class="fc" id="L525">    private val fingerprint: ScriptID,</span>
  ) {
    private var renderedContent: StringBuilder? = null
<span class="fc" id="L528">    private var interpreted: AtomicReference&lt;Source&gt; = AtomicReference(null)</span>

    /** @return The path or some module ID for the embedded script. */
    internal abstract fun getId(): String

    /** @return Script content, loaded synchronously. */
    internal abstract fun load(): String

    // Assign rendered preamble+script content before execution.
    internal fun assignRendered(builder: StringBuilder) {
<span class="nc" id="L538">      renderedContent = builder</span>
<span class="nc" id="L539">    }</span>

    // Assign VM-interpreted source object.
    private fun assignSource(source: Source) {
<span class="nc" id="L543">      interpreted.compareAndSet(</span>
<span class="nc" id="L544">        null,</span>
<span class="nc" id="L545">        source,</span>
      )
<span class="nc" id="L547">    }</span>

    // Evaluate/interpret the rendered output for this script.
    private fun render(): Source {
<span class="nc bnc" id="L551" title="All 4 branches missed.">      val content = renderedContent?.toString() ?: error(</span>
<span class="nc" id="L552">        &quot;Cannot render script before it has been prepared by the JS runtime&quot;</span>
      )
<span class="nc" id="L554">      val source = Source.create(</span>
<span class="nc" id="L555">        &quot;js&quot;,</span>
<span class="nc" id="L556">        content</span>
      )
<span class="nc" id="L558">      assignSource(</span>
<span class="nc" id="L559">        source</span>
      )
<span class="nc" id="L561">      return source</span>
    }

    // Unique and stable ID for this script.
    internal fun fingerprint(): ScriptID {
<span class="nc" id="L566">      return fingerprint</span>
    }

    // Acquire VM-interpreted source object.
    internal fun interpret(): Source {
<span class="nc bnc" id="L571" title="All 2 branches missed.">      return interpreted.get() ?: render()</span>
    }
<span class="fc" id="L573">  }</span>

  /** Embedded script implementation which pulls from local JAR resources. */
<span class="pc" id="L576">  public class EmbeddedScript(</span>
<span class="pc" id="L577">    public val path: String,</span>
<span class="pc" id="L578">    private val charset: Charset = StandardCharsets.UTF_8,</span>
<span class="nc" id="L579">    invocationBase: String? = null,</span>
<span class="nc" id="L580">    invocationTarget: String? = null,</span>
<span class="fc" id="L581">  ): ExecutableScript(</span>
<span class="fc" id="L582">    invocationBase = invocationBase,</span>
<span class="fc" id="L583">    invocationTarget = invocationTarget,</span>
<span class="fc" id="L584">    fingerprint = fingerprintScriptPath(path),</span>
  ) {
    public companion object {
      private const val hashAlgo = &quot;SHA-256&quot;

      // Hash an embedded script path to determine a stable fingerprint value.
      @JvmStatic private fun fingerprintScriptPath(path: String): ScriptID {
<span class="fc" id="L591">        val hasher = MessageDigest.getInstance(hashAlgo)</span>
<span class="fc" id="L592">        hasher.update(path.toByteArray(StandardCharsets.UTF_8))</span>
<span class="fc" id="L593">        return String(</span>
<span class="fc" id="L594">          hasher.digest(),</span>
<span class="fc" id="L595">          StandardCharsets.UTF_8</span>
        )
      }
    }

    /** @inheritDoc */
<span class="nc" id="L601">    override fun getId(): String = path</span>

    /** @inheritDoc */
    override fun load(): String {
<span class="pc bpc" id="L605" title="1 of 2 branches missed.">      val stream = javaClass.getResourceAsStream(path) ?:</span>
<span class="nc" id="L606">      throw FileNotFoundException(&quot;Embedded script not found: '$path'&quot;)</span>

<span class="pc bpc" id="L608" title="1 of 2 branches missed.">      return stream.bufferedReader(charset).use {</span>
<span class="fc" id="L609">        it.readText()</span>
      }
    }
<span class="nc" id="L612">  }</span>

  /** Embedded script implementation which pulls from a string literal. */
<span class="nc" id="L615">  public class LiteralScript(</span>
<span class="nc" id="L616">    private val moduleId: String,</span>
<span class="nc" id="L617">    private val script: String,</span>
<span class="nc" id="L618">    invocationBase: String? = null,</span>
<span class="nc" id="L619">    invocationTarget: String? = null,</span>
<span class="nc" id="L620">  ): ExecutableScript(</span>
<span class="nc" id="L621">    invocationBase = invocationBase,</span>
<span class="nc" id="L622">    invocationTarget = invocationTarget,</span>
<span class="nc" id="L623">    fingerprint = fingerprintScriptContent(moduleId, script)</span>
  ) {
    public companion object {
      private const val hashAlgorithm = &quot;SHA-256&quot;

      // Hash a script to determine a stable fingerprint value.
      @JvmStatic private fun fingerprintScriptContent(moduleId: String, content: String): ScriptID {
<span class="nc" id="L630">        val hasher = MessageDigest.getInstance(hashAlgorithm)</span>
<span class="nc" id="L631">        hasher.update(</span>
<span class="nc" id="L632">          moduleId.toByteArray(StandardCharsets.UTF_8)</span>
        )
<span class="nc" id="L634">        hasher.update(</span>
<span class="nc" id="L635">          content.toByteArray(StandardCharsets.UTF_8)</span>
        )
<span class="nc" id="L637">        return String(Hex.encode(</span>
<span class="nc" id="L638">          hasher.digest()</span>
<span class="nc" id="L639">        ), StandardCharsets.UTF_8)</span>
      }
    }

    /** @inheritDoc */
<span class="nc" id="L644">    override fun getId(): String = moduleId</span>

    /** @inheritDoc */
    override fun load(): String {
<span class="nc" id="L648">      return script</span>
    }
<span class="nc" id="L650">  }</span>

  // Create the singleton script runtime.
<span class="fc" id="L653">  private val runtime: ScriptRuntime = ScriptRuntime()</span>

  @VisibleForTesting
  internal fun &lt;R&gt; evalExecuteScript(
    script: ExecutableScript,
    returnType: Class&lt;R&gt;,
    vararg arguments: Any?
  ): R? {
<span class="nc" id="L661">    val interpreted = runtime.resolve(script)</span>
<span class="nc" id="L662">    val base = script.invocationBase</span>
<span class="nc" id="L663">    val target = script.invocationTarget</span>
<span class="nc bnc" id="L664" title="All 2 branches missed.">    val baseTarget: Value = if (target != null) {</span>
<span class="nc" id="L665">      var baseSegment: Value = interpreted</span>
<span class="nc bnc" id="L666" title="All 2 branches missed.">      val baseResolved = if (base != null) {</span>
<span class="nc" id="L667">        base.split(&quot;.&quot;).forEach {</span>
<span class="nc bnc" id="L668" title="All 2 branches missed.">          baseSegment = baseSegment.getMember(</span>
<span class="nc" id="L669">            it</span>
<span class="nc" id="L670">          ) ?: error(</span>
<span class="nc" id="L671">            &quot;Failed to resolve base segment: '$it' in '$base' was not found&quot;</span>
          )
<span class="nc" id="L673">        }</span>
<span class="nc" id="L674">        baseSegment</span>
      } else {
<span class="nc" id="L676">        interpreted</span>
      }

      // from the resolved base segment, pluck the executable member
<span class="nc bnc" id="L680" title="All 2 branches missed.">      val found = baseResolved.getMember(</span>
<span class="nc" id="L681">        script.invocationTarget,</span>
<span class="nc" id="L682">      ) ?: error(</span>
<span class="nc" id="L683">        &quot;Failed to invoke script member: '${script.getId()}' (fn: '${script.invocationTarget}')&quot;</span>
      )

<span class="nc bnc" id="L686" title="All 2 branches missed.">      if (!found.canExecute()) {</span>
<span class="nc" id="L687">        error(</span>
<span class="nc" id="L688">          &quot;Member found, but not executable, at '${base}.${script.invocationTarget}'&quot;</span>
        )
      } else {
<span class="nc" id="L691">        found</span>
      }
    } else {
      // execute the script directly
<span class="nc" id="L695">      interpreted</span>
    }

    // if we are handed back an executable, execute it, providing the input arguments. in both cases, cast the return
    // value to the expected type.
<span class="nc bnc" id="L700" title="All 2 branches missed.">    return if (baseTarget.canExecute()) {</span>
<span class="nc" id="L701">      baseTarget.execute(</span>
<span class="nc" id="L702">        *arguments</span>
<span class="nc bnc" id="L703" title="All 2 branches missed.">      )?.`as`(</span>
<span class="nc" id="L704">        returnType</span>
      )
    } else {
<span class="nc" id="L707">      interpreted.`as`(</span>
<span class="nc" id="L708">        returnType</span>
      )
    }
  }

  /**
   * Asynchronously execute the provided [script] within an embedded JavaScript VM, by way of GraalVM's runtime engine;
   * de-serialize the result [R] and provide it as the return value.
   *
   * @param script Executable script spec to execute within the embedded JS VM.
   * @return Deferred task which evaluates to the return value [R] when execution finishes.
   */
  @Suppress(&quot;SpreadOperator&quot;)
  private fun &lt;R&gt; executeBackground(
    script: ExecutableScript,
    returnType: Class&lt;R&gt;,
    arguments: Array&lt;out Any?&gt;,
  ): Future&lt;R?&gt; {
    // interpret the script
<span class="nc" id="L727">    return runtime.executor.submit {</span>
<span class="nc" id="L728">      evalExecuteScript(</span>
<span class="nc" id="L729">        script,</span>
<span class="nc" id="L730">        returnType,</span>
<span class="nc" id="L731">        *arguments</span>
      )
    }
  }

  /**
   * Asynchronously execute the provided [script] within an embedded JavaScript VM, by way of GraalVM's runtime engine;
   * de-serialize the result [R] and provide it as the return value.
   *
   * @param script Executable script spec to execute within the embedded JS VM.
   * @return Deferred task which evaluates to the return value [R] when execution finishes.
   */
  public fun &lt;R&gt; executeAsync(script: ExecutableScript, returnType: Class&lt;R&gt;, vararg arguments: Any?): Deferred&lt;R?&gt; {
    // interpret the script
<span class="nc" id="L745">    return executeBackground(</span>
<span class="nc" id="L746">      script,</span>
<span class="nc" id="L747">      returnType,</span>
<span class="nc" id="L748">      arguments,</span>
<span class="nc" id="L749">    ).asDeferred()</span>
  }

  /**
   * Suspension execution of the provided [script] within an embedded JavaScript VM, by way of GraalVM's runtime engine;
   * de-serialize the result [R] and provide it as the return value.
   *
   * @param script Executable script spec to execute within the embedded JS VM.
   * @return Deferred task which evaluates to the return value [R] when execution finishes.
   */
  public suspend fun &lt;R&gt; execute(script: ExecutableScript, returnType: Class&lt;R&gt;, vararg arguments: Any?): R? {
    // interpret the script
<span class="nc" id="L761">    return executeAsync(</span>
<span class="nc" id="L762">      script,</span>
<span class="nc" id="L763">      returnType,</span>
<span class="nc" id="L764">      arguments,</span>
<span class="nc" id="L765">    ).await()</span>
  }

  /**
   * Blocking execution of the provided [script] within an embedded JavaScript VM, by way of GraalVM's runtime engine;
   * de-serialize the result [R] and provide it as the return value.
   *
   * @param script Executable script spec to execute within the embedded JS VM.
   * @return Deferred task which evaluates to the return value [R] when execution finishes.
   */
  public fun &lt;R&gt; executeBlocking(script: ExecutableScript, returnType: Class&lt;R&gt;, vararg arguments: Any?): R? {
    // interpret the script
<span class="nc" id="L777">    return executeBackground(</span>
<span class="nc" id="L778">      script,</span>
<span class="nc" id="L779">      returnType,</span>
<span class="nc" id="L780">      arguments,</span>
<span class="nc" id="L781">    ).get()</span>
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>
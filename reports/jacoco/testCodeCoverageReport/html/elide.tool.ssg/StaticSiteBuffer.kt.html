<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>StaticSiteBuffer.kt</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">reports</a> &gt; <a href="index.source.html" class="el_package">elide.tool.ssg</a> &gt; <span class="el_source">StaticSiteBuffer.kt</span></div><h1>StaticSiteBuffer.kt</h1><pre class="source lang-java linenums">package elide.tool.ssg

import com.google.common.annotations.VisibleForTesting
import kotlinx.coroutines.Deferred
import kotlinx.coroutines.async
import kotlinx.coroutines.coroutineScope as coroutine
import java.io.Closeable
import java.util.Queue
import java.util.concurrent.ConcurrentLinkedQueue
import java.util.concurrent.atomic.AtomicBoolean
import java.util.concurrent.atomic.AtomicInteger

/** Class which holds output fragments and state as they are built within the SSG compiler. */
<span class="fc" id="L14">public class StaticSiteBuffer : Closeable, AutoCloseable {</span>
  // Count of fragments held by the buffer.
<span class="fc" id="L16">  private val fragmentCount: AtomicInteger = AtomicInteger(0)</span>

  // Marked as open until fragments are done, then closed.
<span class="fc" id="L19">  private val open: AtomicBoolean = AtomicBoolean(true)</span>

  // Marked as closed when all fragments and consumption have completed.
<span class="fc" id="L22">  private val closed: AtomicBoolean = AtomicBoolean(false)</span>

  // Whether we are currently iterating over results.
<span class="fc" id="L25">  private val consuming: AtomicBoolean = AtomicBoolean(false)</span>

  // All registered fragments.
<span class="fc" id="L28">  private val allFragments: Queue&lt;StaticFragment&gt; = ConcurrentLinkedQueue()</span>

  /** @inheritDoc */
  override fun close() {
<span class="fc" id="L32">    closed.compareAndSet(false, true)</span>
<span class="fc" id="L33">  }</span>

  // Reset buffer state.
  @VisibleForTesting internal fun reset() {
<span class="fc" id="L37">    allFragments.clear()</span>
<span class="fc" id="L38">    fragmentCount.set(0)</span>
<span class="fc" id="L39">    open.set(true)</span>
<span class="fc" id="L40">    closed.set(false)</span>
<span class="fc" id="L41">  }</span>

  /**
   * Let the buffer know that all pending fragments have completed, and that this current set of fragments constitutes
   * the full set of results.
   *
   * After this call, fragments cannot be added to the buffer; it is marked as closed, which also opens up consumption
   * of the fragments via an iterable.
   *
   * @throws IllegalStateException if the buffer has already been sealed.
   */
  internal fun seal() {
<span class="fc" id="L53">    open.compareAndSet(true, false)</span>
<span class="fc" id="L54">  }</span>

  /** @return Indicate whether the buffer is open. */
<span class="pc bpc" id="L57" title="2 of 4 branches missed.">  internal fun isOpen(): Boolean = open.get() &amp;&amp; !closed.get()</span>

  /** @return Indicate whether the buffer is closed. */
<span class="pc bpc" id="L60" title="3 of 4 branches missed.">  internal fun isClosed(): Boolean = !open.get() &amp;&amp; closed.get()</span>

  /**
   * Add a compiled [StaticFragment] to the current set of buffered fragments.
   *
   * @param fragment Compiled site fragment to add.
   * @return Current count of fragments so far.
   * @throws IllegalStateException if the buffer is sealed.
   */
  internal fun add(fragment: StaticFragment): Int {
<span class="fc bfc" id="L70" title="All 6 branches covered.">    check(open.get() &amp;&amp; !closed.get()) {</span>
<span class="fc" id="L71">      &quot;Output buffer must be in an open state to accept fragments&quot;</span>
    }
<span class="fc" id="L73">    allFragments.add(fragment)</span>
<span class="fc" id="L74">    return fragmentCount.incrementAndGet()</span>
  }

  /** @return Size of the set of fragments in the buffer. */
<span class="fc" id="L78">  public fun size(): Int = fragmentCount.get()</span>

  /**
   * Consume each fragment within the set of [allFragments]; can only be called before the buffer is closed.
   *
   * @return A sequence of all fragments within the buffer.
   * @throws IllegalStateException if the buffer has not yet been sealed, or is closed.
   */
<span class="pc bpc" id="L86" title="1 of 2 branches missed.">  public suspend fun &lt;R: Any&gt; consumeAsync(consumer: suspend (StaticFragment) -&gt; R): List&lt;Deferred&lt;R&gt;&gt; = coroutine {</span>
<span class="pc bpc" id="L87" title="1 of 6 branches missed.">    check(!open.get() &amp;&amp; !closed.get()) {</span>
<span class="fc" id="L88">      &quot;Cannot consume from output buffer while it is open for additional fragments&quot;</span>
    }
<span class="pc bpc" id="L90" title="2 of 4 branches missed.">    check(!consuming.getAndSet(true)) {</span>
<span class="nc" id="L91">      &quot;Cannot consume from output buffer while it is already being consumed&quot;</span>
    }

<span class="fc" id="L94">    var frag = allFragments.poll()</span>
<span class="fc" id="L95">    val jobs: ArrayList&lt;Deferred&lt;R&gt;&gt; = ArrayList()</span>
<span class="fc bfc" id="L96" title="All 2 branches covered.">    while (frag != null) {</span>
      // consume the fragment
<span class="fc" id="L98">      val current = frag</span>
<span class="fc" id="L99">      jobs.add(async {</span>
<span class="fc" id="L100">        consumer.invoke(current)</span>
      })
<span class="fc" id="L102">      frag = allFragments.poll()</span>
    }
<span class="fc" id="L104">    consuming.set(false)</span>
<span class="fc" id="L105">    jobs</span>
<span class="fc" id="L106">  }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>